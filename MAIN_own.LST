C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 1   


C51 COMPILER V8.04b, COMPILATION OF MODULE MAIN_OWN
OBJECT MODULE PLACED IN MAIN_own.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE MAIN_own.C LARGE OBJECTADVANCED OPTIMIZE(9,SPEED) BROWSE ORDER DEFINE(SLAVE
                    -_BOARDS,PRINT_ERROR,PRINT_WARNING,PRINT,PANASONIC_12_CELLS) DEBUG

line level    source

   1          //****************************************************************************
   2          // @Module        Project Settings
   3          // @Filename      MAIN.C
   4          // @Project       BM_Master.dav
   5          //----------------------------------------------------------------------------
   6          // @Controller    Infineon XC886CLM-8FF
   7          //
   8          // @Compiler      Keil
   9          //
  10          // @Codegenerator 
  11          //
  12          // @Description   This file contains the Project initialization function.
  13          //
  14          //----------------------------------------------------------------------------
  15          // @Date          10.08.2007 14:17:24
  16          //
  17          //****************************************************************************
  18          
  19          // USER CODE BEGIN (MAIN_General,1)
  20          // USER CODE END
  21          
  22          
  23          
  24          //****************************************************************************
  25          // @Project Includes
  26          //****************************************************************************
  27          
  28          #include "MAIN.H"
  29          
  30          // USER CODE BEGIN (MAIN_General,2)
  31          #include "Routines.h"
  32          #include "MemoryXC8.h"
  33          #include <stdio.h>
  34          #include <stdlib.h>
  35          #include <math.h>
  36          #include <limits.h>
  37          #include "Flash.h"
  38          #include "Service.h"
  39          
  40          #ifdef SLAVE_BOARDS
  41          #include "Slave.h"
  42          #endif
  43          
  44          
  45          //****************************************************************************
  46          //                         CHECK COMPILER SWITCH
  47          //****************************************************************************
  48          #if defined (SLAVE_BOARDS)
  49                  #if defined (A123_BATTERY_10_CELLS)
                          #message "A123: Slave + 10 Cells"   
                      #elif defined (LITEC_BATTERY_12_CELLS)
                            #message "Litec: Slave + 12 Cells" 
                      #elif defined (PANASONIC_12_CELLS) || defined (MAXWELL_12_CELLS)
  54                            #message "Panasonic/Maxwell: Slave + 12 Cells"
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 2   

*** MESSAGE C320 IN LINE 54 OF MAIN_own.C: "Panasonic/Maxwell: Slave + 12 Cells"
  55                  #elif defined (MAXWELL_9_CELLS)
                                #message "Maxwell: Slave + 9 Cells - not yet adapted..."
                      #else
                        #error "Slave: wrong compiler switch"
                      #endif
  60          #else
                #error "wrong compiler switch"
              #endif
  63           
  64          
  65          // USER CODE END
  66          
  67          
  68          //****************************************************************************
  69          // @Macros
  70          //****************************************************************************
  71          
  72          // USER CODE BEGIN (MAIN_General,3)
  73          
  74          // USER CODE END
  75          
  76          
  77          //****************************************************************************
  78          // @Defines
  79          //****************************************************************************
  80          
  81          // USER CODE BEGIN (MAIN_General,4)
  82          
  83          // USER CODE END
  84          
  85          
  86          //****************************************************************************
  87          // @Switches
  88          //****************************************************************************
  89          
  90          // USER CODE BEGIN (MAIN_General,5)
  91          //SLAVE_BOARDS SM_LIGHT PRINT_ERROR PRINT FLASH_DATA A123_BATTERY_10_CELLS
  92          //SLAVE_BOARDS SM_LIGHT PRINT_ERROR PRINT FLASH_DATA LITEC_BATTERY_12_CELLS
  93          //SLAVE_BOARDS SM_LIGHT PRINT_ERROR PRINT FLASH_DATA PANASONIC_12_CELLS
  94          //SLAVE_BOARDS SM_LIGHT PRINT_ERROR PRINT FLASH_DATA MAXWELL_12_CELLS
  95          //SLAVE_BOARDS SM_LIGHT PRINT_ERROR PRINT FLASH_DATA MAXWELL_9_CELLS
  96          
  97          //#define SLAVE_BOARDS
  98          //#define PRINT
  99          //#define PRINT_ERROR
 100          //#define PRINT_WARNING
 101          //#define FLASH_DATA 
 102          //#define A123_BATTERY_10_CELLS or LITEC_BATTERY_12_CELLS or PANASONIC_12_CELLS or MAXWELL_12_CELLS or MAX
             -WELL_9_CELLS
 103          //#define SM_LIGHT
 104          
 105          // USER CODE END
 106          
 107          
 108          //****************************************************************************
 109          // @Imported Global Variables
 110          //****************************************************************************
 111          
 112          // USER CODE BEGIN (MAIN_General,6)
 113          
 114          // ADC register definition
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 3   

 115          sfr16   RESULT_REGISTER_0   =  0xCA;
 116          sfr16   RESULT_REGISTER_1       =  0xCC;
 117          sfr16   RESULT_REGISTER_2       =  0xCE;
 118          sfr16   RESULT_REGISTER_3       =  0xD2;
 119          
 120          // MDU register definition
 121          sfr16   MDU_Operand1 =  0xB2; 
 122          sfr16   MDU_Operand2 =  0xB4;
 123          sfr16   MDU_Operand3 =  0xB6;
 124          
 125          // USER CODE END
 126          
 127          
 128          //****************************************************************************
 129          // @Global Variables
 130          //****************************************************************************
 131          
 132          // USER CODE BEGIN (MAIN_General,7)
 133          volatile SlaveData sSlaveData;
 134          volatile SlaveData *pSlaveData = &sSlaveData; 
 135          volatile char idata FLAG_Pin;
 136          // USER CODE END
 137          
 138          
 139          //****************************************************************************
 140          // @External Prototypes
 141          //****************************************************************************
 142          
 143          
 144          // USER CODE BEGIN (MAIN_General,8)
 145          
 146          // USER CODE END
 147          
 148          
 149          //****************************************************************************
 150          // @Prototypes Of Local Functions
 151          //****************************************************************************
 152          
 153          // USER CODE BEGIN (MAIN_General,9)
 154          
 155          void MeasSequentialChannels_1_to_3(SlaveData *pSlaveData);
 156          void MeasParallelChannels_4_to_7(SlaveData *pSlaveData);
 157          void MeasSequentialChannel_0(SlaveData *pSlaveData);
 158          void IsTemperatureAndBlockOutOfRange(SlaveData *pSlaveData);
 159          void IsAnyCellOutOfRange(SlaveData *pSlaveData);
 160          void Print(SlaveData *pSlaveData);
 161          void PrintAll(SlaveData *pSlaveData);
 162          void PrintDigit(SlaveData *pSlaveData);
 163          void CellBalancing(SlaveData *pSlaveData);
 164          void NormalMode(SlaveData *pSlaveData);
 165          char BoardIdentification(SlaveData *pSlaveData);
 166          void ScanTempAndBlockVoltage(SlaveData *pSlaveData);
 167          void ScanCells(SlaveData *pSlaveData);
 168          void MDU_ScaleCells(SlaveData *pSlaveData);
 169          void BalancingType(char Type);
 170          void CheckTempAndBlock( SlaveData *pSlaveData );
 171          void CheckCells( SlaveData *pSlaveData );
 172          void CheckAllConditions(char *STATE, SlaveData *pSlaveData, unsigned int *loop);
 173          void CheckCellConditions(char *STATE, SlaveData *pSlaveData, unsigned int *loop);
 174          void CheckBlockConditions(char *STATE, SlaveData *pSlaveData, unsigned int *loop);
 175          void CheckComCondition(char *STATE, SlaveData *pSlaveData, unsigned int *loop);
 176          
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 4   

 177          
 178          // USER CODE END
 179          
 180          
 181          //****************************************************************************
 182          // @Function      void MAIN_vInit(void) 
 183          //
 184          //----------------------------------------------------------------------------
 185          // @Description   This function initializes the microcontroller. It is 
 186          //                assumed that the SFRs are in their reset state.
 187          //
 188          //----------------------------------------------------------------------------
 189          // @Returnvalue   None
 190          //
 191          //----------------------------------------------------------------------------
 192          // @Parameters    None
 193          //
 194          //----------------------------------------------------------------------------
 195          // @Date          10.08.2007
 196          //
 197          //****************************************************************************
 198          
 199          // USER CODE BEGIN (MAIN_Init,1)
 200          
 201          // USER CODE END
 202          
 203          void MAIN_vInit(void)
 204          {
 205   1        // USER CODE BEGIN (MAIN_Init,2)
 206   1      
 207   1        // USER CODE END
 208   1      
 209   1        ///  -----------------------------------------------------------------------
 210   1        ///  Configuration of the System Clock:
 211   1        ///  -----------------------------------------------------------------------
 212   1        ///  - External Osc is selected (configuration is done in the startup file 
 213   1        ///    'START_XC.A51')
 214   1        ///  - PLL Mode, NDIV =  24
 215   1        ///  - input frequency is 8 MHz
 216   1      
 217   1      
 218   1        //   FCLK runs at 2 times the frequency of PCLK.
 219   1        SFR_PAGE(_su1, noSST);         // switch to page1
 220   1      
 221   1        CMCON         =  0x10;         // load Clock Control Register
 222   1      
 223   1        SFR_PAGE(_su0, noSST);         // switch to page0
 224   1      
 225   1      
 226   1        ///  *********************************************************************************
 227   1        ///  Note : All peripheral related IO configurations are done in the 
 228   1        ///  respective peripheral modules (alternate functions selection)
 229   1        ///  *********************************************************************************
 230   1      
 231   1        ///  Initialization of module 'GPIO'
 232   1        IO_vInit();
 233   1      
 234   1        ///  Initialization of module 'Interrupt Unit'
 235   1        INT_vInit();
 236   1      
 237   1        ///  Initialization of module 'UART (Serial Interface)'
 238   1        UART_vInit();
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 5   

 239   1      
 240   1      //GK  ///  Initialization of module 'Timer 0/1'
 241   1      //GK  T01_vInit();
 242   1      
 243   1        ///  Initialization of module 'Analog / Digital Converter (ADC)'
 244   1        ADC_vInit();
 245   1      
 246   1        ///  Initialization of module 'Capture / Compare Unit 6 (CCU6)'
 247   1        CC6_vInit();
 248   1        
 249   1        ///  Initialization of module 'MultiCAN Controller '    
 250   1        CAN_vInit();
 251   1      
 252   1        ///  Initialization of  'Shared interrupts'
 253   1      //  SHINT_vInit();
 254   1      
 255   1      
 256   1        //   Interrupt Priority
 257   1      
 258   1        IP            =  0x20;         // load Interrupt Priority Register
 259   1        IPH           =  0x00;         // load Interrupt Priority High Register
 260   1        IP1           =  0x20;         // load Interrupt Priority 1 Register
 261   1        IPH1          =  0x30;         // load Interrupt Priority 1 High Register
 262   1      
 263   1      
 264   1        // USER CODE BEGIN (MAIN_Init,3)
 265   1      
 266   1        //// Interrupt structure 2 mode 0 is selected.
 267   1      
 268   1        //// Interrupt service routine choice 2 is selected.
 269   1      
 270   1        //   globally enable interrupts
 271   1        EA            =  1;           
 272   1      
 273   1      } //  End of function MAIN_vInit
 274          
 275          
 276          //****************************************************************************
 277          // @Function      void main(void) 
 278          //
 279          //----------------------------------------------------------------------------
 280          // @Description   This is the main function.
 281          //
 282          //----------------------------------------------------------------------------
 283          // @Returnvalue   None
 284          //
 285          //----------------------------------------------------------------------------
 286          // @Parameters    None
 287          //
 288          //----------------------------------------------------------------------------
 289          // @Date          10.08.2007
 290          //
 291          //****************************************************************************
 292          
 293          // USER CODE BEGIN (MAIN_Main,1)
 294             
 295          // USER CODE END
 296          
 297          void main(void)
 298          {
 299   1        // USER CODE BEGIN (MAIN_Main,2)
 300   1            
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 6   

 301   1        // USER CODE END
 302   1      
 303   1        MAIN_vInit();
 304   1        TI = 1;
 305   1        CLEAR; POS;
 306   1        
 307   1        //********************************************************
 308   1        //                          INIT
 309   1        //********************************************************
 310   1        {
 311   2         unsigned int i, n;
 312   2         unsigned char* r;
 313   2         
 314   2      
 315   2      #if defined (A123_BATTERY_10_CELLS)    
                 SFR_PAGE(_cc1, noSST);         // switch to page 1           
                 CCU6_T12PRL    =  0x62;        // load CCU6 T12 period register low     (4,125µs)
                 CCU6_T12PRH    =  0x00;        // load CCU6 T12 period register lhigh
                 SFR_PAGE(_cc0, noSST);         // switch to page 0
                 CCU6_TCTR4L    =  0x40;        // load CCU6 timer control register 4 low
                 CCU6_TCTR4H    =  0x40;        // load CCU6 timer control register 4 high
              #elif defined (LITEC_BATTERY_12_CELLS)
                 SFR_PAGE(_cc1, noSST);         // switch to page 1           
                 CCU6_T12PRL    =  0xAA;        // load CCU6 T12 period register low     (7,125µs)
                 CCU6_T12PRH    =  0x00;        // load CCU6 T12 period register lhigh
                 SFR_PAGE(_cc0, noSST);         // switch to page 0
                 CCU6_TCTR4L    =  0x40;        // load CCU6 timer control register 4 low
                 CCU6_TCTR4H    =  0x40;        // load CCU6 timer control register 4 high
              #elif defined (MAXWELL_12_CELLS)
                 SFR_PAGE(_cc1, noSST);         // switch to page 1        
                 CCU6_T12PRL    =  0x47;        // load CCU6 T12 period register low     (3,0µs)
                 CCU6_T12PRH    =  0x00;        // load CCU6 T12 period register lhigh
                 SFR_PAGE(_cc0, noSST);         // switch to page 0
                 CCU6_TCTR4L    =  0x40;        // load CCU6 timer control register 4 low
                 CCU6_TCTR4H    =  0x40;        // load CCU6 timer control register 4 high
              #endif    
 337   2          
 338   2            
 339   2         r = (unsigned char *)&sSlaveData;   
 340   2         n = (unsigned int)sizeof(sSlaveData)/sizeof(unsigned char);
 341   2         for(i=0; i<n; i++)
 342   2           *(unsigned char *)(r+i) = 0x00;
 343   2      
 344   2         // set to IN-Block balancing
 345   2         sSlaveData.BLOCK_BALANCING = IN_BLOCK;   
 346   2         
 347   2         // set Sek pins to 0
 348   2         for(i=0; i<Cells; i++)                               
 349   2            //DeactivateSek(i);
 350   2                SekOff[i]();
 351   2      
 352   2         // set Prim_H to 0
 353   2         PrimH_Off();
 354   2      
 355   2      //   // switch PORTS: either JTAG or SM_LIGHT
 356   2      //#ifdef SM_LIGHT  
 357   2      //   SFR_PAGE(_pp1, noSST);         // switch to page 1
 358   2      //   P0_PUDEN      =  0x40;         // load pullup/pulldown enable register  
 359   2      //   SFR_PAGE(_pp0, noSST);         // switch to page 0
 360   2      //   // clear Pins
 361   2      //   P0_0=1; P0_1=1; P0_2=1;
 362   2      //   P0_DIR        =  0xBF;         // load direction register
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 7   

 363   2      //#else
 364   2      //   SFR_PAGE(_pp1, noSST);         // switch to page 1
 365   2      //   P0_PUDEN      =  0x44;         // load pullup/pulldown enable register
 366   2      //   SFR_PAGE(_pp0, noSST);         // switch to page 0
 367   2      //   P0_DIR        =  0xB8;         // load direction register
 368   2      //#endif
 369   2       
 370   2         // clear flag
 371   2         NMISR &= ~(ubyte)0x02;         // clear FNMIPLL
 372   2        }
 373   1       
 374   1        // USER CODE BEGIN (MAIN_Main,3)
 375   1       
 376   1      
 377   1      //*****************************************************
 378   1      //                             MENU
 379   1      //*****************************************************
 380   1        printf("\033[2J");
 381   1        printf("\n-BATTERY MANAGEMENT %s %s-\n uC SW Version:%s \n", __DATE__, __TIME__, VERSION);
 382   1        // read corr. factors                                                                                                   
 383   1        FlashReadBoardCorrValues(pSlaveData);
 384   1                 
 385   1      
 386   1      //   while(1)
 387   1      //   {
 388   1      //     CAN_vTransmit(5);
 389   1      //       printf("Test\n");
 390   1      //     { unsigned int i;
 391   1      //     for(i=0; i<60000; i++)
 392   1      //      _nop_(); 
 393   1      //     }  
 394   1      //   }   
 395   1      
 396   1      
 397   1      
 398   1      //********************************************************
 399   1      //                                START
 400   1      //********************************************************
 401   1        // USER CODE END
 402   1      
 403   1        while(1)
 404   1        {  
 405   2        // USER CODE BEGIN (MAIN_Main,4)               
 406   2              NormalMode(pSlaveData);
 407   2      
 408   2        // USER CODE END
 409   2        }
 410   1      
 411   1      } //  End of function main
 412          
 413          
 414          // USER CODE BEGIN (MAIN_General,10)
 415          
 416          
 417          //*******************************************************
 418          //
 419          //                 GENERAL FUNCTIONS
 420          //
 421          //********************************************************
 422          
 423          //********************************************************
 424          //                               PRINT ELEMENTS
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 8   

 425          //********************************************************                
 426          void Print(SlaveData *pSlaveData)
 427          {
 428   1      #if defined (PRINT)  
 429   1         BLINK;
 430   1         printf("\nMeasurement:\n");
 431   1         ATTRIBUTE_OFF;
 432   1         printf(" Tmin:%7dC Tmax:%4dC \n",   ((int)pSlaveData->Tmin), ((int)pSlaveData->Tmax));                                       // format Q.
             -0
 433   1         printf(" Umin:%7.2fV Umax:%4.2fV\n",(float)pSlaveData->Umin_u/4096, (float)pSlaveData->Umax_u/4096);         /
             -/ format Q.12
 434   1         printf(" Ublock:%5.2fV\n\n",        (float)pSlaveData->Ublock/256);                                                                          // format Q.8
 435   1         printf(" Udiff:%6.2fV\n",           (float)pSlaveData->Umax_u/4096 - (float)pSlaveData->Umin_u/4096);        /
             -/ format Q.12
 436   1         printf(" Uaver:%6.2fV\n",           (float)pSlaveData->Uaver_u/4096);                                  
             -  // format Q.12                                                                                                 
 437   1      #endif
 438   1      }
 439          
 440          void PrintAll(SlaveData *pSlaveData)
 441          {
 442   1      #if defined (PRINT)  
 443   1         BLINK;
 444   1         printf("\nMeasurement:\n");
 445   1         ATTRIBUTE_OFF;
 446   1         printf(" Tmin:%7dC Tmax:%4dC \n",     (int)pSlaveData->Tmin, (int)pSlaveData->Tmax);                                         // format Q.0
 447   1         printf(" Umin:%7.3fV Umax:%4.3fV\n\n",(float)pSlaveData->Umin_u/4096, (float)pSlaveData->Umax_u/4096); 
             -        // format Q.12
 448   1         
 449   1         printf(" Temp1:%6dC \n Temp2:%6dC \n Temp3:%6dC \n", ((int)pSlaveData->T_R5), ((int)pSlaveData->T_R6), 
             -((int)pSlaveData->T_R7));  // format Q.0 
 450   1         printf(" Tboard:%5dC \n\n",(int)pSlaveData->T_Rboard);                                                                                                                                                // format Q.0
 451   1      
 452   1         printf(" U0corr:%5.3fV \n",   (float)pSlaveData->Umux_u[0]/4096);  // format Q.12 
 453   1         printf(" U1corr:%5.3fV \n",   (float)pSlaveData->Umux_u[1]/4096);
 454   1         printf(" U2corr:%5.3fV \n",   (float)pSlaveData->Umux_u[2]/4096);
 455   1         printf(" U3corr:%5.3fV \n",   (float)pSlaveData->Umux_u[3]/4096);
 456   1         printf(" U4corr:%5.3fV \n",   (float)pSlaveData->Umux_u[4]/4096);
 457   1         printf(" U5corr:%5.3fV \n",   (float)pSlaveData->Umux_u[5]/4096);
 458   1         printf(" U6corr:%5.3fV \n",   (float)pSlaveData->Umux_u[6]/4096);  
 459   1         printf(" U7corr:%5.3fV \n",   (float)pSlaveData->Umux_u[7]/4096);
 460   1         printf(" U8corr:%5.3fV \n",   (float)pSlaveData->Umux_u[8]/4096);
 461   1         printf(" U9corr:%5.3fV \n",   (float)pSlaveData->Umux_u[9]/4096);
 462   1         printf(" U10corr:%4.3fV \n",  (float)pSlaveData->Umux_u[10]/4096);
 463   1         printf(" U11corr:%4.3fV \n\n",(float)pSlaveData->Umux_u[11]/4096);
 464   1         
 465   1         printf(" Ublock:%5.3fV\n\n",  (float)pSlaveData->Ublock/256);                                    // for
             -mat Q.8
 466   1         printf(" Udiff:%6.3fV \n",    (float)pSlaveData->Umax_u/4096 - (float)pSlaveData->Umin_u/4096);      // form
             -at Q.12
 467   1         printf(" Uaver:%6.3fV \n",    (float)pSlaveData->Uaver_u/4096);                                  // for
             -mat Q.12                                                                                                                
             -                                                                                                                        
             -                         
 468   1      #endif
 469   1      }
 470          
 471          void PrintDigit(SlaveData *pSlaveData)
 472          {
 473   1         printf("\n U0dig:%d \n",(int)pSlaveData->Umux_dig[0]);   
 474   1         printf(" U1dig:%d \n",(int)pSlaveData->Umux_dig[1]);
 475   1         printf(" U2dig:%d \n",(int)pSlaveData->Umux_dig[2]);
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 9   

 476   1         printf(" U3dig:%d \n",(int)pSlaveData->Umux_dig[3]);
 477   1         printf(" U4dig:%d \n",(int)pSlaveData->Umux_dig[4]);
 478   1         printf(" U5dig:%d \n",(int)pSlaveData->Umux_dig[5]);
 479   1         printf(" U6dig:%d \n",(int)pSlaveData->Umux_dig[6]);  
 480   1         printf(" U7dig:%d \n",(int)pSlaveData->Umux_dig[7]);
 481   1         printf(" U8dig:%d \n",(int)pSlaveData->Umux_dig[8]);
 482   1         printf(" U9dig:%d \n",(int)pSlaveData->Umux_dig[9]);
 483   1         printf(" U10dig:%d\n",(int)pSlaveData->Umux_dig[10]);
 484   1         printf(" U11dig:%d\n\n",(int)pSlaveData->Umux_dig[11]);
 485   1      
 486   1         printf(" blockdig:%d\n\n",(int)pSlaveData->Umux_dig_block);
 487   1      //added by XI
 488   1      
 489   1      }
 490          
 491          
 492          //********************************************************
 493          //                               NORMAl MODE
 494          //********************************************************                
 495          void NormalMode(SlaveData *pSlaveData)
 496          {   
 497   1      #ifdef SLAVE_BOARDS   
 498   1         
 499   1         unsigned int Data         = 0;
 500   1         //unsigned char SYNCH       = 0;
 501   1         static char STATE         = State_Reset;
 502   1         static unsigned int loop  = 0;
 503   1         //unsigned long reset_loop;
 504   1            
 505   1          
 506   1         // SLAVE STATE - MACHINE
 507   1         switch( STATE )
 508   1         {
 509   2            
 510   2               case State_Normal:                                      // LED on -> only for debug
 511   2                                                   printf("STATE - Normal S%bu\n", pSlaveData->Name);
 512   2                                                   // check sensors and block voltage
 513   2                                                   CheckTempAndBlock( pSlaveData );
 514   2                                                                                       // check all cells
 515   2                                                                                       CheckCells( pSlaveData );
 516   2                                                                                                                                                               
 517   2                                                                                       // printf
 518   2                                                                                       Print(pSlaveData);
 519   2                                               // has slave been requested?
 520   2                                               SlaveHasBeenPinged(pSlaveData);                                                                                                              
             -                    
 521   2                                               // store CAN relevant values
 522   2                                               SlavePrepareOwnBoardDataForCAN(pSlaveData);
 523   2                                                                                                                
             -             
 524   2                                               // Cell balancing
 525   2                                               CellBalancing(pSlaveData);
 526   2                                                                                       // check all conditions
 527   2                                                                                       CheckAllConditions(&STATE, pSlaveData, &loop);
 528   2                                                                                       
 529   2                                                           break;
 530   2           
 531   2           case State_CellConditionInvalid:    // LED on -> only for debug
 532   2                                                   LED_CellConditionInvalid; printf("STATE - CellCon invalid\n");          
             -                                
 533   2                                                                                       // scan all cells
 534   2                                                                                       CheckCells( pSlaveData );                                                                               
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 10  

 535   2                                                                                       // printf
 536   2                                                                                       Print(pSlaveData);
 537   2                                               // Cell balancing
 538   2                                               CellBalancing(pSlaveData);
 539   2                                                                                       // check cell conditions
 540   2                                                                                       CheckCellConditions(&STATE, pSlaveData, &loop);
 541   2      
 542   2                                                           break;
 543   2      
 544   2               case State_NoCommunication:             // LED on -> only for debug
 545   2                                                   LED_NoCommunication; printf("STATE - No Com, S%bx gets no request\n"
             -, pSlaveData->Name);                                       
 546   2                                                   // has slave been requested?
 547   2                                                   SlaveHasBeenPinged(pSlaveData);                                                                                     
 548   2                                                   // check communication condition
 549   2                                                   CheckComCondition(&STATE, pSlaveData, &loop);
 550   2      
 551   2                                                           break;
 552   2      
 553   2               case State_Synch:                                       // LED on -> only for debug
 554   2                                                   printf("STATE - Synch\n");
 555   2                                                   // check sensors and block voltage
 556   2                                                   CheckTempAndBlock(pSlaveData);
 557   2                                               // store CAN relevant values
 558   2                                               SlavePrepareOwnBoardDataForCAN(pSlaveData);                                                                            
 559   2                                                                                       // check all conditions
 560   2                                                                                       CheckAllConditions(&STATE, pSlaveData, &loop);                                                                  
 561   2                                                                                       
 562   2                                                           break;
 563   2      
 564   2               case State_BlockConditionInvalid:       // LED on -> only for debug
 565   2                                                   LED_BlockConditionInvalid; printf("STATE - BlockCon invalid\n");
 566   2                                                   // check sensors and block voltage
 567   2                                                                                       CheckTempAndBlock( pSlaveData );                                                                               
 568   2                                                                                       // printf
 569   2                                                                                       Print(pSlaveData);
 570   2                                                                                       // check block conditions
 571   2                                                                                       CheckBlockConditions(&STATE, pSlaveData, &loop);                                                                        
 572   2                                                                                       
 573   2                                                           break;
 574   2      
 575   2               case State_Reset:                   // LED on -> only for debug
 576   2                                                   printf("STATE - ResetS%bu\n", pSlaveData->Name);
 577   2                                               
 578   2                                               // calculate error flash address
 579   2                                               FlashCalculateAdr(pSlaveData);
 580   2                                               // read errror/warning value                                     
             -                                              
 581   2                                               FlashReadErrors(pSlaveData);
 582   2                                                                                           
 583   2                                                   // check sensors and block voltage
 584   2                                                   CheckTempAndBlock(pSlaveData);
 585   2                                               // who is who?
 586   2                                               BoardIdentification(pSlaveData); 
 587   2      
 588   2                                               // without the request the slave can't start                                                                           
 589   2                                                   if( SlaveHasBeenRequested(pSlaveData) )
 590   2                                                 // read command in the pipe
 591   2                                                 SlaveErrorProcessing(pSlaveData);                                                                                                                                                                     
             -  
 592   2                                                                                         
 593   2                                                   // slave starts with inter- or intra block balancing?
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 11  

 594   2                                                   SlaveHasBeenPinged(pSlaveData);                                                                                     
 595   2                                                                                       // check all conditions
 596   2                                                                                       CheckAllConditions(&STATE, pSlaveData, &loop);                                                                  
 597   2                                  
 598   2                                                                                       break;
 599   2      
 600   2               default:                                                        printf("State unknown!!!\n");
 601   2                                                   break;
 602   2         }
 603   1         
 604   1         // clear error bit
 605   1         pSlaveData->Error     = NoError;
 606   1         // clear error type
 607   1         pSlaveData->ErrorType = NoErrorType;
 608   1      
 609   1      #endif  //end SLAVE
 610   1      
 611   1      
 612   1         //************************************************
 613   1         //                press 'ESC' for stop
 614   1         //************************************************
 615   1         // clear flag
 616   1         NMISR &= ~(ubyte)0x02;         // clear FNMIPLL
 617   1                 
 618   1         if(RI)
 619   1         { 
 620   2           RI=0;
 621   2      
 622   2           if(SBUF==0x65) //press 'e' = erase errors
 623   2           {
 624   3                 // erase D-flash1 sector 1
 625   3                 DFlErase(0, DFL1_SEC1);
 626   3                 // wait until ready
 627   3                 while(FlReady(4) == 0);                                                        
 628   3                 // erase D-flash1 sector 0
 629   3                 DFlErase(0, DFL1_SEC0);
 630   3                 // wait until ready
 631   3                 while(FlReady(4) == 0);
 632   3                 // read flash address
 633   3                 FlashCalculateAdr(pSlaveData);
 634   3      
 635   3                 printf("Erase Sectors 0 and 1\n");
 636   3           }
 637   2      
 638   2               if(SBUF==0x70) //press 'p' = print
 639   2               {
 640   3             printf(" Temp1:%6.1fC \n Temp2:%6.1fC \n Temp3:%6.1fC \n", (float)pSlaveData->T_R5, (float)pSlaveDa
             -ta->T_R6, (float)pSlaveData->T_R7 );    /* format Q.0 */
 641   3             printf(" Tboard:%5.1fC \n\n",(float)pSlaveData->T_Rboard);        // format Q.0
 642   3             printf(" U0corr:%5.2fV \n",(float)pSlaveData->Umux_u[0]/4096);    // format Q.12
 643   3             printf(" U1corr:%5.2fV \n",(float)pSlaveData->Umux_u[1]/4096);
 644   3             printf(" U2corr:%5.2fV \n",(float)pSlaveData->Umux_u[2]/4096);
 645   3             printf(" U3corr:%5.2fV \n",(float)pSlaveData->Umux_u[3]/4096);
 646   3             printf(" U4corr:%5.2fV \n",(float)pSlaveData->Umux_u[4]/4096);
 647   3             printf(" U5corr:%5.2fV \n",(float)pSlaveData->Umux_u[5]/4096);
 648   3             printf(" U6corr:%5.2fV \n",(float)pSlaveData->Umux_u[6]/4096);  
 649   3             printf(" U7corr:%5.2fV \n",(float)pSlaveData->Umux_u[7]/4096);
 650   3             printf(" U8corr:%5.2fV \n",(float)pSlaveData->Umux_u[8]/4096);
 651   3             printf(" U9corr:%5.2fV \n",(float)pSlaveData->Umux_u[9]/4096);
 652   3             printf(" U10corr:%4.2fV \n",  (float)pSlaveData->Umux_u[10]/4096);
 653   3             printf(" U11corr:%4.2fV \n\n",(float)pSlaveData->Umux_u[11]/4096);
 654   3               }
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 12  

 655   2      
 656   2           if(SBUF==0x72) //press 'r' = read flash error
 657   2               {
 658   3             // calculate error flash address
 659   3             FlashCalculateAdr(pSlaveData);
 660   3             // read
 661   3             FlashReadErrors(pSlaveData);
 662   3               }
 663   2         }                                                                              
 664   1      }
 665          
 666          
 667          
 668          //********************************************************
 669          //              TOP-/BOTTOM- or INTERBLOCK BALANCING
 670          //********************************************************                
 671          void CellBalancing(SlaveData *pSlaveData)
 672          {      
 673   1         unsigned int idata Umax_Uaver_u, Uaver_Umin_u;
 674   1      
 675   1         // calculate difference from Umax/Umin to Uaver
 676   1         Umax_Uaver_u        = pSlaveData->Umax_u  - pSlaveData->Uaver_u;
 677   1         Uaver_Umin_u        = pSlaveData->Uaver_u - pSlaveData->Umin_u;
 678   1         pSlaveData->Udiff_u = pSlaveData->Umax_u  - pSlaveData->Umin_u;
 679   1      
 680   1         // check     the difference between Umin and Umax and wait for
 681   1         // appr. the same time we have in case of balancing 3-4s    
 682   1         if( pSlaveData->Udiff_u <= U50mV && !(pSlaveData->BLOCK_BALANCING & INTER_BLOCK))
 683   1         {                                                                            
 684   2           // printf nothing to do
 685   2           #if defined (PRINT)  
 686   2            printf("\n---\n");
 687   2           #endif
 688   2      
 689   2           LED_NOBALANCING;
 690   2           // pause of the same length needed for Bottom-/Top- and InterBlockBalancing
 691   2               // Bottom Balancing
 692   2               BalancingType(DUMMY_BALANCING);
 693   2               
 694   2               return;
 695   2         }   
 696   1      
 697   1         // INTER- or IN-Balancing
 698   1         if( (Umax_Uaver_u < Uaver_Umin_u) && !(pSlaveData->BLOCK_BALANCING & INTER_BLOCK) )
 699   1         { 
 700   2           // printf cell which is bottom balanced
 701   2           #if defined (PRINT)
 702   2            printf("\nBottomBalance:%bd\n", pSlaveData->BalanceCellIndex[pSlaveData->LowestCellIndex]);
 703   2           #endif
 704   2                 
 705   2           LED_BOTTOM;                 
 706   2               // Bottom Balancing
 707   2               BalancingType(BOTTOM_BALANCING);
 708   2         }
 709   1         else  
 710   1         {       
 711   2           // printf cell which is top balanced
 712   2           if( pSlaveData->BLOCK_BALANCING & INTER_BLOCK )
 713   2               {
 714   3             #if defined (PRINT)       
 715   3              printf("\nINTER Block Balance:%bd\n", pSlaveData->BalanceCellIndex[0]);
 716   3             #endif
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 13  

 717   3      
 718   3                 LED_INTERBLOCK;
 719   3                 // InterBlock Balancing
 720   3                 BalancingType(INTERBLOCK_BALANCING);
 721   3               }
 722   2               else
 723   2               {
 724   3             #if defined (PRINT)       
 725   3              printf("\nTopBalance:%bd\n", pSlaveData->BalanceCellIndex[0]);
 726   3             #endif
 727   3      
 728   3                 LED_TOP;
 729   3                 // Top Balancing
 730   3                 BalancingType(TOP_BALANCING);
 731   3               }
 732   2         }
 733   1      
 734   1         // primH off
 735   1         PrimH_Off(); 
 736   1      }
 737          
 738          void BalancingType(char Type)
 739          {
 740   1         //#define PulseNo    
 741   1         unsigned int idata loop;
 742   1         
 743   1         // load var.
 744   1         loop = 65535u;
 745   1         // balancing
 746   1         while(loop--)
 747   1         {
 748   2           // bottom balancing
 749   2           BalancingFunction[Type](pSlaveData); 
 750   2           // delay because of the energy bilanz 
 751   2           DELAY_30();
 752   2         }
 753   1      }
 754          
 755          
 756          //********************************************************
 757          //                           CALCULATE CELL RANGE
 758          //********************************************************                
 759          void IsAnyCellOutOfRange(SlaveData *pSlaveData)
 760          {        
 761   1         // error: is any cell over level?
 762   1         if(pSlaveData->Umax_u > UoverLevel)
 763   1         {  
 764   2           // error message
 765   2           pSlaveData->Error     |= CellOverLevel;
 766   2               pSlaveData->ErrorType |= BoardFailure;
 767   2         #if defined (PRINT_ERROR) 
 768   2           printf("Error: Ucell[%bd] over level\n", pSlaveData->BalanceCellIndex[0]);
 769   2         #endif
 770   2         }  
 771   1          
 772   1         // error: is any cell under level?
 773   1         if(pSlaveData->Umin_u < UunderLevel)
 774   1         {  
 775   2           // error message
 776   2           pSlaveData->Error     |= CellUnderLevel;
 777   2               pSlaveData->ErrorType |= BoardFailure;
 778   2         #if defined (PRINT_ERROR)
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 14  

 779   2           printf("Error: Ucell[%bd] under level\n", pSlaveData->BalanceCellIndex[pSlaveData->LowestCellIndex]);
 780   2         #endif
 781   2         }
 782   1      }
 783          
 784          //********************************************************
 785          //                        CALCULATE TEMPERATURE RANGE
 786          //********************************************************                
 787          void IsTemperatureAndBlockOutOfRange(SlaveData *pSlaveData)
 788          {
 789   1         // warning: is any temp over 280°C?
 790   1         if(pSlaveData->Tmax > ShortCut)
 791   1         {
 792   2               pSlaveData->Warning |= TempShortCut;
 793   2          #if defined (PRINT_WARNING)  
 794   2               printf("Warning: T%bd ShortCut\n", pSlaveData->TempIndex[0]);
 795   2          #endif
 796   2         } 
 797   1         else //clear bit
 798   1          pSlaveData->Warning &= ~TempShortCut;
 799   1           
 800   1         
 801   1         // warning: is any temp under -220°C?
 802   1         if(pSlaveData->Tmin < Open)
 803   1         {
 804   2               // warning message
 805   2               pSlaveData->Warning |= TempOpen;
 806   2         #if defined (PRINT_WARNING)
 807   2               printf("Warning: T%bd Open\n", pSlaveData->TempIndex[TempSensors-1]);
 808   2         #endif
 809   2         }
 810   1         else //clear bit
 811   1              pSlaveData->Warning &= ~TempOpen;
 812   1         
 813   1      
 814   1         // error: is any temp over 75°C?
 815   1         if( (pSlaveData->Tmax > T75) && (pSlaveData->Tmax < QuasiShortCut) )  
 816   1         {   
 817   2               // error message
 818   2               pSlaveData->Error     |= TempOverLevel;
 819   2               pSlaveData->ErrorType |= BoardFailure;
 820   2         #if defined (PRINT_ERROR)
 821   2           printf("Error: T%bd over 75C\n", pSlaveData->TempIndex[0]);
 822   2         #endif
 823   2         }  
 824   1      
 825   1         // error is Ublock
 826   1         if(pSlaveData->Ublock <= UblockUnderLevel)
 827   1         {
 828   2           // error
 829   2           pSlaveData->Error     |= BlockUnderLevel;
 830   2               pSlaveData->ErrorType |= BoardFailure;
 831   2         #if defined (PRINT_ERROR)
 832   2           printf("Error: Ublock under level\n");
 833   2         #endif
 834   2         }
 835   1      }
 836          
 837          
 838          char BoardIdentification(SlaveData *pSlaveData)
 839          {
 840   1      //#if defined (SLAVE_BOARDS)
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 15  

 841   1                                 
 842   1        // POSITION 0: u > 4,84V
 843   1        if(pSlaveData->Uident >= U4_84V)                                                                      
 844   1        { 
 845   2              // wrong ID
 846   2              pSlaveData->Name = -1;
 847   2          printf("Slave: Service mode\n");
 848   2              // deallocate all objects
 849   2          SlaveDeallocateAllMessageObjects();
 850   2              // allocate all relevant MOs
 851   2              SlaveAllocateRelevantMessageObjects((char)-16);
 852   2          // single block charging
 853   2          ServiceMode(pSlaveData);
 854   2        }
 855   1      
 856   1        // POSITION 1: 4,53V to 4,84V
 857   1        if(      U4_53V < pSlaveData->Uident && pSlaveData->Uident < U4_84V)
 858   1        {
 859   2              pSlaveData->Name = SlaveBoard0;
 860   2              // deallocate all objects
 861   2          SlaveDeallocateAllMessageObjects();
 862   2              // allocate all relevant MOs
 863   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 864   2              // return ID
 865   2              return pSlaveData->Name;         
 866   2        }  // POSITION 2: 4,25V - 4,53V
 867   1        else if(U4_25V < pSlaveData->Uident && pSlaveData->Uident <= U4_53V)
 868   1        {
 869   2              pSlaveData->Name = SlaveBoard1;
 870   2              // deallocate all objects
 871   2          SlaveDeallocateAllMessageObjects();
 872   2              // allocate all relevant MOs
 873   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);  
 874   2              // return ID
 875   2              return pSlaveData->Name;                
 876   2        }      // POSITION 3: 4,02V - 4,25V
 877   1        else if(U4_02V < pSlaveData->Uident && pSlaveData->Uident <= U4_25V)
 878   1        {
 879   2              pSlaveData->Name = SlaveBoard2;
 880   2              // deallocate all objects
 881   2          SlaveDeallocateAllMessageObjects();
 882   2              // allocate all relevant MOs
 883   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 884   2              // return ID    
 885   2              return pSlaveData->Name;                                
 886   2        }      // POSITION 4: 3,81V - 4,02V
 887   1        else if(U3_81V < pSlaveData->Uident && pSlaveData->Uident <= U4_02V)
 888   1        {
 889   2              pSlaveData->Name = SlaveBoard3;
 890   2              // deallocate all objects
 891   2          SlaveDeallocateAllMessageObjects();
 892   2              // allocate all relevant MOs
 893   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 894   2              // return ID    
 895   2              return pSlaveData->Name;                                
 896   2        }      // POSITION 5: 3,61V - 3,81V
 897   1        else if(U3_61V < pSlaveData->Uident && pSlaveData->Uident <= U3_81V)
 898   1        {
 899   2              pSlaveData->Name = SlaveBoard4;
 900   2              // deallocate all objects
 901   2          SlaveDeallocateAllMessageObjects();
 902   2              // allocate all relevant MOs
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 16  

 903   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 904   2              // return ID    
 905   2              return pSlaveData->Name;                                
 906   2        }      // POSITION 6: 3,43V - 3,61V
 907   1        else if(U3_43V < pSlaveData->Uident && pSlaveData->Uident <= U3_61V)
 908   1        {
 909   2              pSlaveData->Name = SlaveBoard5;
 910   2              // deallocate all objects
 911   2          SlaveDeallocateAllMessageObjects();
 912   2              // allocate all relevant MOs
 913   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 914   2              // return ID    
 915   2              return pSlaveData->Name;                                
 916   2        }      // POSITION 7: 3,28V - 3,43V
 917   1        else if(U3_28V < pSlaveData->Uident && pSlaveData->Uident <= U3_43V)
 918   1        {
 919   2              pSlaveData->Name = SlaveBoard6;
 920   2              // deallocate all objects
 921   2          SlaveDeallocateAllMessageObjects();
 922   2              // allocate all relevant MOs
 923   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 924   2              // return ID    
 925   2              return pSlaveData->Name;                                
 926   2        }      // POSITION 8: 3,14V - 3,28V
 927   1        else if(U3_14V < pSlaveData->Uident && pSlaveData->Uident <= U3_28V)
 928   1        {
 929   2              pSlaveData->Name = SlaveBoard7;
 930   2              // deallocate all objects
 931   2          SlaveDeallocateAllMessageObjects();
 932   2              // allocate all relevant MOs
 933   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 934   2              // return ID    
 935   2              return pSlaveData->Name;                                
 936   2        }      // POSITION 9: 3,00V - 3,14V
 937   1        else if(U3_00V < pSlaveData->Uident && pSlaveData->Uident <= U3_14V)
 938   1        {
 939   2              pSlaveData->Name = SlaveBoard8;
 940   2              // deallocate all objects
 941   2          SlaveDeallocateAllMessageObjects();
 942   2              // allocate all relevant MOs
 943   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 944   2              // return ID    
 945   2              return pSlaveData->Name;                                
 946   2        }      // POSITION 10: 2,88V - 3,00V
 947   1        else if(U2_88V < pSlaveData->Uident && pSlaveData->Uident <= U3_00V)
 948   1        {
 949   2              pSlaveData->Name = SlaveBoard9;
 950   2              // deallocate all objects
 951   2          SlaveDeallocateAllMessageObjects();
 952   2              // allocate all relevant MOs
 953   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 954   2              // return ID    
 955   2              return pSlaveData->Name;                                
 956   2        }      // POSITION 11: 2,77V - 2,88V
 957   1        else if(U2_77V < pSlaveData->Uident && pSlaveData->Uident <= U2_88V)
 958   1        {
 959   2              pSlaveData->Name = SlaveBoard10;
 960   2              // deallocate all objects
 961   2          SlaveDeallocateAllMessageObjects();
 962   2              // allocate all relevant MOs
 963   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 964   2              // return ID    
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 17  

 965   2              return pSlaveData->Name;                                
 966   2        }      // POSITION 12: 2,67V - 2,77V
 967   1        else if(U2_67V < pSlaveData->Uident && pSlaveData->Uident <= U2_77V)
 968   1        {
 969   2              pSlaveData->Name = SlaveBoard11;
 970   2              // deallocate all objects
 971   2          SlaveDeallocateAllMessageObjects();
 972   2              // allocate all relevant MOs
 973   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 974   2              // return ID    
 975   2              return pSlaveData->Name;                                
 976   2        }      // POSITION 13: 2,57V - 2,67V
 977   1        else if(U2_57V < pSlaveData->Uident && pSlaveData->Uident <= U2_67V)
 978   1        {
 979   2              pSlaveData->Name = SlaveBoard12;
 980   2              // deallocate all objects
 981   2          SlaveDeallocateAllMessageObjects();
 982   2              // allocate all relevant MOs
 983   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 984   2              // return ID    
 985   2              return pSlaveData->Name;                                
 986   2        }      // POSITION 14: 2,48V - 2,57V
 987   1        else if(U2_48V < pSlaveData->Uident && pSlaveData->Uident <= U2_57V)
 988   1        {
 989   2              pSlaveData->Name = SlaveBoard13;
 990   2              // deallocate all objects
 991   2          SlaveDeallocateAllMessageObjects();
 992   2              // allocate all relevant MOs
 993   2              SlaveAllocateRelevantMessageObjects(pSlaveData->Name);
 994   2              // return ID    
 995   2              return pSlaveData->Name;                                
 996   2        }      // POSITION 15: <2,48V
 997   1        else 
 998   1        {
 999   2              // wrong ID
1000   2          printf("\n->wrong Slave ID, position 0xF is already reserved!!!\n");
1001   2              while(1);
1002   2        }
1003   1      //#endif
1004   1      }
1005          
1006          //********************************************************
1007          //
1008          //                      partial SCAN
1009          //
1010          //********************************************************
1011          void ScanTempAndBlockVoltage(SlaveData *pSlaveData)
1012          {
1013   1         int idata res0, res1, res2, res3;
1014   1          
1015   1         //**********************************
1016   1         //     CHANNEL 0-3: Temp0-Temp3
1017   1         //**********************************
1018   1         // start channel 0 (Temp Rref)
1019   1         ADC_vStartSeqReqChNum(0, 0, 0, 0);
1020   1         // start channel 1 (Temp R5)
1021   1         ADC_vStartSeqReqChNum(0, 0, 0, 1);
1022   1         // start channel 2 (Temp R6)
1023   1         ADC_vStartSeqReqChNum(0, 0, 0, 2);
1024   1         // start channel 3 (Temp R7)
1025   1         ADC_vStartSeqReqChNum(0, 0, 0, 3);  
1026   1              
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 18  

1027   1         // wait as long as busy and result register 0/1/2/3 and sequential request 1 is set 
1028   1         while(ADC_ubGetEventInterruptFlag() != 0xF1);
1029   1         
1030   1         // read data from result register 0
1031   1         res0 = ADC_uwGetResultData0();   
1032   1         // read data from result register 1
1033   1         res1 = ADC_uwGetResultData1();
1034   1         // read data from result register 2 
1035   1         res2 = ADC_uwGetResultData2();
1036   1         // read data from result register 3 
1037   1         res3 = ADC_uwGetResultData3();   
1038   1         // clear event flags
1039   1         ADC_vClearEventInterruptFlag(0xF1);
1040   1             
1041   1         // calculate temperature     T5, T6, T7
1042   1         pSlaveData->T_R5   = MDU_Convert_ADC2Temp(res1);
1043   1         pSlaveData->T_R6   = MDU_Convert_ADC2Temp(res2);
1044   1         pSlaveData->T_R7   = MDU_Convert_ADC2Temp(res3); 
1045   1      
1046   1         //***********************************
1047   1         //  CHANNEL 4-6: Tboard, Uident, Ublock
1048   1         //***********************************
1049   1         // start channel 4 (Tboard)
1050   1         ADC_vStartSeqReqChNum(0, 0, 0, 4);
1051   1         // start channel 5 (Uident)
1052   1         ADC_vStartSeqReqChNum(0, 0, 0, 5);
1053   1         // start channel 6 (Ublock)
1054   1         ADC_vStartSeqReqChNum(0, 0, 0, 6);
1055   1              
1056   1         // wait as long as busy and result register 0/1/2 and sequential request 1 is set 
1057   1         while(ADC_ubGetEventInterruptFlag() != 0x71);
1058   1         
1059   1         // read data from result register 0
1060   1         res0 = ADC_uwGetResultData0();   
1061   1         // read data from result register 1
1062   1         res1 = ADC_uwGetResultData1();
1063   1         // read data from result register 2 
1064   1         res2 = ADC_uwGetResultData2();   
1065   1         // clear event flags
1066   1         ADC_vClearEventInterruptFlag(0x71);
1067   1      
1068   1         // calculate Tboard, Uident, Ublock
1069   1         pSlaveData->T_Rboard = MDU_Convert_ADC2Temp(res0);
1070   1         pSlaveData->Uident   = res1; // =ID
1071   1      
1072   1          pSlaveData->Umux_dig_block = res2;
1073   1      //added by XI    
1074   1      
1075   1      
1076   1         //pSlaveData->Ublock   = MDU_Convert_ADC2UBlock(res2);
1077   1      
1078   1         //pSlaveData->Ublock = res2 * 40 * sSlaveData.Ufac_u[Cells] / 2;
1079   1         pSlaveData->Ublock = res2 *5*11*256/1024;
1080   1         //added by Ningyi     
1081   1      }
1082          
1083          //********************************************************
1084          //
1085          //                SCAN ALL ADC-CHANNELS
1086          //
1087          //********************************************************
1088          void ScanCells(SlaveData *pSlaveData)
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 19  

1089          {
1090   1         volatile int idata res3;
1091   1         volatile char idata i, j;
1092   1      
1093   1      #if defined (A123_BATTERY_10_CELLS)
                      char j_end = 8;
                      char j_inc = j_end-1;
                      char i_off = Cell_5;
              #elif defined (MAXWELL_9_CELLS)
                      char j_end = 9;
                      char j_inc = j_end-1;
                      char i_off = Cell_5;
              #elif defined (LITEC_BATTERY_12_CELLS) || defined (PANASONIC_12_CELLS) || defined (MAXWELL_12_CELLS) 
1102   1              char j_end = 1;
1103   1              char j_inc = 1;
1104   1              char i_off = Cells;
1105   1      #endif
1106   1      
1107   1         //EA = 0;
1108   1         DisableCANInterrupt();
1109   1      
1110   1         // set Prim_H on     
1111   1         PrimH_On(); 
1112   1      
1113   1         // set Prim_L 
1114   1         PrimL_On();
1115   1         DELAY_25();  //3µs
1116   1         PrimL_Off();
1117   1      
1118   1         DELAY_200(); //50µs
1119   1      
1120   1         //***********************************
1121   1         //     CHANNEL 7: Umux Sek0-Sek4, Umux Sek7-Sek11
1122   1         //***********************************
1123   1         for(j=0; j<j_end; j=j+j_inc)
1124   1         {
1125   2           for (i=0+j; i<i_off+j; i++)
1126   2           {                                           
1127   3             // set Voltage Number
1128   3             FLAG_Pin = i;       
1129   3             // start sequential conversion (external trigger)
1130   3             ADC_vStartSeqReqChNum(1, 0, 0, 7);   
1131   3          
1132   3             // set Prim_H on     
1133   3             PrimH_On(); 
1134   3          
1135   3          DELAY_80(); //+18µs -> 24µs   
1136   3          
1137   3                 // set Prim_L 
1138   3                 PrimL_On(); 
1139   3                 // wait
1140   3                 DELAY_2();     
1141   3      
1142   3      /* 
1143   3           // clear PrimL
1144   3           PrimL_Off();
1145   3               // wait
1146   3               DELAY_3();
1147   3           // set Sek
1148   3           SekOn[FLAG_Pin]();  
1149   3           // start Timer 12 to trigger                       
1150   3           CC6_vStartTmr(CC6_TIMER_12);                  
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 20  

1151   3           // wait until timer is running (TR12-BIT)
1152   3           while(CCU6_TCTR0L & 0x10);
1153   3           // wait until ADC sample (SAMPLE-BIT) 
1154   3           while( !(ADC_GLOBSTR & 0x2) );                                                                                
1155   3               // clear Sek
1156   3               SekOff[FLAG_Pin]();
1157   3      */
1158   3                 
1159   3             // switch port pin on
1160   3             //  = ActivateSek(FLAG_Pin)                                      
1161   3                 switch(FLAG_Pin)
1162   3                 {
1163   4                    case 0:  // clear PrimL
1164   4                             PrimL_Off();
1165   4                                         // wait
1166   4                                 DELAY_3();
1167   4                             // set Sek
1168   4                             SekOn_0();  
1169   4                         // start Timer 12 to trigger                         
1170   4                         CC6_vStartTmr(CC6_TIMER_12);            
1171   4                         // wait until timer is running (TR12-BIT)
1172   4                         while(CCU6_TCTR0L & 0x10);
1173   4                         // wait until ADC sample (SAMPLE-BIT) 
1174   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1175   4                                         // clear Sek
1176   4                                         SekOff_0();
1177   4                             break;
1178   4      
1179   4                    case 1:  // clear PrimL
1180   4                             PrimL_Off();
1181   4                                 // wait
1182   4                                 DELAY_3();
1183   4                             // set Sek
1184   4                             SekOn_1();  
1185   4                         // start Timer 12 to trigger                         
1186   4                         CC6_vStartTmr(CC6_TIMER_12);            
1187   4                         // wait until timer is running (TR12-BIT)
1188   4                         while(CCU6_TCTR0L & 0x10);
1189   4                         // wait until ADC sample (SAMPLE-BIT) 
1190   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1191   4                                         // clear Sek
1192   4                                         SekOff_1();
1193   4                             break;
1194   4      
1195   4                    case 2:  // clear PrimL
1196   4                             PrimL_Off(); 
1197   4                                 // wait
1198   4                                 DELAY_3();
1199   4                             // set Sek
1200   4                             SekOn_2(); 
1201   4                         // start Timer 12 to trigger                         
1202   4                         CC6_vStartTmr(CC6_TIMER_12);            
1203   4                         // wait until timer is running (TR12-BIT)
1204   4                         while(CCU6_TCTR0L & 0x10);
1205   4                         // wait until ADC sample (SAMPLE-BIT) 
1206   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1207   4                                         // clear Sek
1208   4                                         SekOff_2();                          
1209   4                             break;
1210   4      
1211   4                    case 3:  // clear PrimL
1212   4                             PrimL_Off();
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 21  

1213   4                                 // wait
1214   4                                 DELAY_3();
1215   4                             // set Sek
1216   4                             SekOn_3(); 
1217   4                         // start Timer 12 to trigger                         
1218   4                         CC6_vStartTmr(CC6_TIMER_12);            
1219   4                         // wait until timer is running (TR12-BIT)
1220   4                         while(CCU6_TCTR0L & 0x10);
1221   4                         // wait until ADC sample (SAMPLE-BIT) 
1222   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1223   4                                         // clear Sek
1224   4                                         SekOff_3();                          
1225   4                             break;
1226   4      
1227   4                    case 4:  // clear PrimL
1228   4                             PrimL_Off();
1229   4                                 // wait
1230   4                                 DELAY_3();
1231   4                             // set Sek
1232   4                             SekOn_4(); 
1233   4                         // start Timer 12 to trigger                         
1234   4                         CC6_vStartTmr(CC6_TIMER_12);            
1235   4                         // wait until timer is running (TR12-BIT)
1236   4                         while(CCU6_TCTR0L & 0x10);
1237   4                         // wait until ADC sample (SAMPLE-BIT) 
1238   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1239   4                                         // clear Sek
1240   4                                         SekOff_4();                          
1241   4                             break;
1242   4      
1243   4                    case 5:  // clear PrimL
1244   4                             PrimL_Off();
1245   4                                 // wait
1246   4                                 DELAY_3();
1247   4                             // set Sek
1248   4                             SekOn_5(); 
1249   4                         // start Timer 12 to trigger                         
1250   4                         CC6_vStartTmr(CC6_TIMER_12);            
1251   4                         // wait until timer is running (TR12-BIT)
1252   4                         while(CCU6_TCTR0L & 0x10);
1253   4                         // wait until ADC sample (SAMPLE-BIT) 
1254   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1255   4                                         // clear Sek
1256   4                                         SekOff_5();                          
1257   4                             break;
1258   4      
1259   4                    case 6:  // clear PrimL
1260   4                             PrimL_Off();
1261   4                                 // wait
1262   4                                 DELAY_3();
1263   4                             // set Sek
1264   4                             SekOn_6(); 
1265   4                         // start Timer 12 to trigger                         
1266   4                         CC6_vStartTmr(CC6_TIMER_12);            
1267   4                         // wait until timer is running (TR12-BIT)
1268   4                         while(CCU6_TCTR0L & 0x10);
1269   4                         // wait until ADC sample (SAMPLE-BIT) 
1270   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1271   4                                         // clear Sek
1272   4                                         SekOff_6();                          
1273   4                             break;
1274   4      
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 22  

1275   4                    case 7:  // clear PrimL
1276   4                             PrimL_Off();
1277   4                                 // wait
1278   4                                 DELAY_3();
1279   4                             // set Sek
1280   4                             SekOn_7();  
1281   4                         // start Timer 12 to trigger                         
1282   4                         CC6_vStartTmr(CC6_TIMER_12);            
1283   4                         // wait until timer is running (TR12-BIT)
1284   4                         while(CCU6_TCTR0L & 0x10);
1285   4                         // wait until ADC sample (SAMPLE-BIT) 
1286   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1287   4                                         // clear Sek
1288   4                                         SekOff_7();
1289   4                             break;
1290   4      
1291   4                    case 8:  // clear PrimL
1292   4                             PrimL_Off();
1293   4                                 // wait
1294   4                                 DELAY_3();
1295   4                             // set Sek
1296   4                             SekOn_8(); 
1297   4                         // start Timer 12 to trigger                         
1298   4                         CC6_vStartTmr(CC6_TIMER_12);            
1299   4                         // wait until timer is running (TR12-BIT)
1300   4                         while(CCU6_TCTR0L & 0x10);
1301   4                         // wait until ADC sample (SAMPLE-BIT) 
1302   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1303   4                                         // clear Sek
1304   4                                         SekOff_8();                          
1305   4                             break;
1306   4      
1307   4                    case 9:  // clear PrimL
1308   4                             PrimL_Off();
1309   4                                 // wait
1310   4                                 DELAY_3();
1311   4                             // set Sek
1312   4                             SekOn_9(); 
1313   4                         // start Timer 12 to trigger                         
1314   4                         CC6_vStartTmr(CC6_TIMER_12);            
1315   4                         // wait until timer is running (TR12-BIT)
1316   4                         while(CCU6_TCTR0L & 0x10);
1317   4                         // wait until ADC sample (SAMPLE-BIT) 
1318   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1319   4                                         // clear Sek
1320   4                                         SekOff_9();
1321   4                             break;
1322   4      
1323   4                    case 10: // clear PrimL
1324   4                             PrimL_Off();
1325   4                                 // wait
1326   4                                 DELAY_3();
1327   4                             // set Sek
1328   4                             SekOn_10(); 
1329   4                         // start Timer 12 to trigger                         
1330   4                         CC6_vStartTmr(CC6_TIMER_12);            
1331   4                         // wait until timer is running (TR12-BIT)
1332   4                         while(CCU6_TCTR0L & 0x10);
1333   4                         // wait until ADC sample (SAMPLE-BIT) 
1334   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1335   4                                         // clear Sek
1336   4                                         SekOff_10();
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 23  

1337   4                             break;
1338   4      
1339   4                    case 11: // clear PrimL
1340   4                             PrimL_Off();
1341   4                                 // wait
1342   4                                 DELAY_3();
1343   4                             // set Sek
1344   4                             SekOn_11();
1345   4                         // start Timer 12 to trigger                         
1346   4                         CC6_vStartTmr(CC6_TIMER_12);            
1347   4                         // wait until timer is running (TR12-BIT)
1348   4                         while(CCU6_TCTR0L & 0x10);
1349   4                         // wait until ADC sample (SAMPLE-BIT) 
1350   4                         while( !(ADC_GLOBSTR & 0x2) );                                                                                  
1351   4                                         // clear Sek
1352   4                                         SekOff_11();                         
1353   4                             break;
1354   4      
1355   4                        default: break;
1356   4             }   
1357   3      
1358   3      
1359   3             // if result register 3 and sequential request 1 is set   
1360   3             while(ADC_ubGetEventInterruptFlag() != 0x81);
1361   3                 
1362   3             // read result register
1363   3             res3 = ADC_uwGetResultData3();
1364   3             // clear event flag
1365   3             ADC_vClearEventInterruptFlag(0x81);       
1366   3             
1367   3             // integer data processing
1368   3             pSlaveData->Umux_dig[FLAG_Pin] = res3;   
1369   3                 
1370   3                 printf(" Udig:%d \n",(int)pSlaveData->Umux_dig[FLAG_Pin]);
1371   3      //         printf(" Udig:%d \n",(int)pSlaveData->Umux_dig[FLAG_PIN]);
1372   3      //added by XI
1373   3                 
1374   3                  
1375   3             pSlaveData->Umux_u[FLAG_Pin]   = MDU_Convert_ADC(res3);   
1376   3                 //pSlaveData->Umux_u[FLAG_Pin] = MDU_Convert_ADC_rough(res3);
1377   3             //pSlaveData->Umux_u[FLAG_Pin] = res3;       
1378   3             //printf("Umux[%bd]:%u\n", (char)FLAG_Pin, (unsigned int)pSlaveData->Umux_u[FLAG_Pin]);
1379   3             
1380   3             // set Prim_H off     
1381   3             PrimH_Off();       
1382   3           }
1383   2         }
1384   1         //printf("\n\n");
1385   1      
1386   1         //***********************************
1387   1         //     CHANNEL 7: Umux Sek5-Sek6
1388   1         //***********************************   
1389   1      #if defined (A123_BATTERY_10_CELLS)   
                 // integer data processing    
                 pSlaveData->Umux_u[5] = 0;
                 // integer data processing    
                 pSlaveData->Umux_u[6] = 0;
              #elif defined (MAXWELL_9_CELLS)   
                 // integer data processing    
                 pSlaveData->Umux_u[5] = 0;
                 // integer data processing    
                 pSlaveData->Umux_u[6] = 0;
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 24  

                 // integer data processing    
                 pSlaveData->Umux_u[7] = 0;
              #endif
1402   1      
1403   1         // scale the cells to Ublock
1404   1         MDU_ScaleCells(pSlaveData);
1405   1      
1406   1         //EA = 1;
1407   1         EnableCANInterrupt();
1408   1      }
1409          
1410          //***********************************
1411          //   Sum calculation and Average
1412          //***********************************   
1413          void MDU_ScaleCells(SlaveData *pSlaveData)
1414          {
1415   1         char idata i;
1416   1         int idata res1;
1417   1         int diff=0;
1418   1         unsigned int idata res2;
1419   1      
1420   1      
1421   1         //************************
1422   1         //          SUM
1423   1         //************************    
1424   1         // clear variable
1425   1         pSlaveData->Umux_scale_ul = 0;
1426   1         // calculate SUM
1427   1         #if defined (A123_BATTERY_10_CELLS)                
                  // sum all voltages from U0 to U9
                  for(i=0; i<5; i++) 
                   pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12     
                  for(i=7; i<Cells; i++) 
                   pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12 
                 #elif defined (MAXWELL_9_CELLS)
                  // sum all voltages from U0 to U9
                  for(i=0; i<5; i++) 
                   pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12     
                  for(i=8; i<Cells; i++) 
                   pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12 
                 #elif defined (LITEC_BATTERY_12_CELLS) || defined (PANASONIC_12_CELLS) || defined (MAXWELL_12_CELLS)
1440   1          for(i=0; i<Cells; i++) 
1441   1           pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12     
1442   1         #endif
1443   1      
1444   1         //************************
1445   1         //    DIFFERENCE/Cell
1446   1         //************************
1447   1         // calulate difference
1448   1         //pSlaveData->Umux_scale_ul = pSlaveData->Umux_scale_ul>>4;
1449   1         //diff = pSlaveData->Ublock - (unsigned int)pSlaveData->Umux_scale_ul; // format Q.8  
1450   1         
1451   1      //***********   
1452   1         diff = (int)((unsigned long)(pSlaveData->Ublock<<4) - pSlaveData->Umux_scale_ul); // format Q.12  
1453   1      //***********   
1454   1         // diff/Cells
1455   1         SYSCON0 |= 0x01;
1456   1         MDU_Operand1 = (int)diff;                             // format Q.12         !!!
1457   1         #if defined (A123_BATTERY_10_CELLS)    
                  MDU_Operand3 = (Cells-2);
                 #elif defined (MAXWELL_9_CELLS)
                      MDU_Operand3 = (Cells-3);
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 25  

                 #elif defined (LITEC_BATTERY_12_CELLS) || defined (PANASONIC_12_CELLS) || defined (MAXWELL_12_CELLS)
1462   1          MDU_Operand3 = Cells;        
1463   1         #endif        
1464   1         MDU_MDUCON = 0x15;                                    // signed 16/16-bit Division   
1465   1         while((MDU_MDUSTAT & 0x04)== 0x04);          
1466   1         res1 = MDU_Operand1;
1467   1         _nop_();
1468   1         SYSCON0 &= 0xFE;
1469   1         
1470   1         //************************
1471   1         //        NEW Cell
1472   1         //************************   
1473   1         #if defined (A123_BATTERY_10_CELLS)                
                  // sum all voltages from U0 to U11
                  for(i=0; i<5; i++) 
                   pSlaveData->Umux_u[i] += (int)res1; // format Q.12     
                  for(i=7; i<Cells; i++) 
                   pSlaveData->Umux_u[i] += (int)res1; // format Q.12 
                 #elif defined (MAXWELL_9_CELLS)
                  // sum all voltages from U0 to U11
                  for(i=0; i<5; i++) 
                   pSlaveData->Umux_u[i] += (int)res1; // format Q.12     
                  for(i=8; i<Cells; i++) 
                   pSlaveData->Umux_u[i] += (int)res1; // format Q.12 
                 #elif defined(LITEC_BATTERY_12_CELLS) || defined (PANASONIC_12_CELLS) || defined (MAXWELL_12_CELLS)
1486   1          for(i=0; i<Cells; i++) 
1487   1           pSlaveData->Umux_u[i] += (int)res1; // format Q.12     
1488   1         #endif
1489   1      
1490   1         //************************
1491   1         //        NEW SUM
1492   1         //************************   
1493   1         // clear variable
1494   1         pSlaveData->Umux_scale_ul = 0;
1495   1         // calculate SUM
1496   1         #if defined (A123_BATTERY_10_CELLS)                
                  // sum all voltages from U0 to U9
                  for(i=0; i<5; i++) 
                   pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12    
                  for(i=7; i<Cells; i++) 
                   pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12 
                 #elif defined (MAXWELL_9_CELLS)
                  // sum all voltages from U0 to U9
                  for(i=0; i<5; i++) 
                   pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12    
                  for(i=8; i<Cells; i++) 
                   pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12 
                 #elif defined (LITEC_BATTERY_12_CELLS) || defined (PANASONIC_12_CELLS) || defined (MAXWELL_12_CELLS)
1509   1          for(i=0; i<Cells; i++) 
1510   1           pSlaveData->Umux_scale_ul += pSlaveData->Umux_u[i];   // format Q.12     
1511   1         #endif      
1512   1      
1513   1         //************************
1514   1         //         AVERAGE
1515   1         //************************      
1516   1         SYSCON0 |= 0x01;
1517   1         // Uaver = Umux_scale/Cells;
1518   1         MDU_Operand1 = (unsigned int)(pSlaveData->Umux_scale_ul & 0xFFFF);
1519   1         MDU_Operand2 = (unsigned int)(pSlaveData->Umux_scale_ul >> 16) & 0xFFFF;  
1520   1         
1521   1         #if defined (A123_BATTERY_10_CELLS)    
                  MDU_Operand3 = (Cells-2);
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 26  

                 #elif defined (MAXWELL_9_CELLS)
                      MDU_Operand3 = (Cells-3);
                 #elif defined(LITEC_BATTERY_12_CELLS) || defined (PANASONIC_12_CELLS) || defined (MAXWELL_12_CELLS)
1526   1          MDU_Operand3 = Cells;        
1527   1         #endif
1528   1         
1529   1         MDU_MDUCON = 0x12;                                    // unsigned 32/16-bit Division   
1530   1         while((MDU_MDUSTAT & 0x04)== 0x04);          
1531   1         res2 = MDU_Operand1;                                  // format Q.12
1532   1         pSlaveData->Uaver_u = res2;
1533   1         SYSCON0 &= 0xFE;
1534   1      }
1535          
1536          
1537          void CheckTempAndBlock( SlaveData *pSlaveData )
1538          {
1539   1              // scan all Temperature sensors
1540   1          ScanTempAndBlockVoltage(pSlaveData);
1541   1          // sort all Temp
1542   1          GetAndSortTemperature(pSlaveData);
1543   1          // temp processing  >75°C
1544   1          IsTemperatureAndBlockOutOfRange(pSlaveData);
1545   1      }
1546          
1547          void CheckCells( SlaveData *pSlaveData )
1548          {
1549   1              // scan all cells
1550   1              ScanCells(pSlaveData);                                         
1551   1          // sort all cells
1552   1          GetAndSortAllCellVoltages(pSlaveData);                                              
1553   1          // cell processing
1554   1          IsAnyCellOutOfRange(pSlaveData);
1555   1      }
1556          
1557          void CheckAllConditions(char *STATE, SlaveData *pSlaveData, unsigned int *loop)
1558          {      
1559   1         // check cell conditions = BoardFailure
1560   1         if ( pSlaveData->Error & (TempOverLevel | BlockUnderLevel) )
1561   1         {
1562   2           // new state
1563   2           *STATE = State_BlockConditionInvalid;      
1564   2           // clear
1565   2           *loop=0;
1566   2         }
1567   1         // check block conditions = BoardFailure
1568   1         else if( pSlaveData->Error & (CellOverLevel | CellUnderLevel) )
1569   1         {
1570   2           // new state
1571   2           *STATE = State_CellConditionInvalid; 
1572   2           // clear
1573   2           *loop=0;                                                                                     
1574   2         }
1575   1         // check com conditions
1576   1         else if( pSlaveData->Error & SlaveGetsNoPing )
1577   1         {
1578   2           // new state
1579   2           *STATE = State_NoCommunication; 
1580   2           // clear
1581   2           *loop=0;                                                                                     
1582   2         }
1583   1         else
1584   1         {
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 27  

1585   2           // old state
1586   2           *STATE = State_Normal; 
1587   2           // clear
1588   2           *loop=0;                                                                                     
1589   2         }
1590   1      }
1591          
1592          
1593          // check cell conditions
1594          void CheckCellConditions(char *STATE, SlaveData *pSlaveData, unsigned int *loop)
1595          {
1596   1         // check conditions = BoardFailure
1597   1         if(pSlaveData->Error & (CellOverLevel | CellUnderLevel) )
1598   1         {
1599   2           // some sec
1600   2           if((*loop)++ > Time_CellConditionInvalid)
1601   2           {                                                   
1602   3                // read command in the pipe
1603   3            SlaveErrorProcessing(pSlaveData);                                                                                     
1604   3                // clear 
1605   3            *loop = 0;
1606   3           }
1607   2           // old state
1608   2           *STATE = State_CellConditionInvalid; 
1609   2         }
1610   1         else
1611   1         {
1612   2           // new state
1613   2           *STATE = State_Normal; 
1614   2           // clear
1615   2           *loop=0;
1616   2         }                                                 
1617   1      }
1618          
1619          void CheckBlockConditions(char *STATE, SlaveData *pSlaveData, unsigned int *loop)
1620          {
1621   1         // check conditions = BoardFailure
1622   1         if( pSlaveData->Error & (TempOverLevel | BlockUnderLevel) )
1623   1         {        
1624   2           // some sec
1625   2           if((*loop)++ > Time_BlockConditionInvalid)
1626   2           {                                                   
1627   3             // read command in the pipe
1628   3             SlaveErrorProcessing(pSlaveData);                                                                                    
1629   3             // clear 
1630   3             *loop = 0;
1631   3           }
1632   2           // old state
1633   2           *STATE = State_BlockConditionInvalid;      
1634   2         }
1635   1         else
1636   1         { 
1637   2           // new state
1638   2           *STATE = State_Synch; 
1639   2           // clear
1640   2           *loop=0;
1641   2         }
1642   1      }
1643          
1644          void CheckComCondition(char *STATE, SlaveData *pSlaveData, unsigned int *loop)
1645          {
1646   1         // error processing                                           
C51 COMPILER V8.04b   MAIN_OWN                                                             03/17/2010 10:20:45 PAGE 28  

1647   1         if( pSlaveData->Error & SlaveGetsNoPing )
1648   1         {                                            
1649   2           // some sec
1650   2           if((*loop)++ > Time_NoCommunication)
1651   2           {                                                                                                          
1652   3             // read command in the pipe
1653   3             SlaveErrorProcessing(pSlaveData);                                                                                    
1654   3             // clear 
1655   3             *loop = 0;
1656   3           }
1657   2                
1658   2           // old state
1659   2           *STATE = State_NoCommunication; 
1660   2         }
1661   1         else
1662   1         {
1663   2           // new state
1664   2           *STATE = State_Synch; 
1665   2           // clear
1666   2           *loop=0;
1667   2         }
1668   1      }
1669          
1670          
1671          
1672          // USER CODE END


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8432    ----
   CONSTANT SIZE    =   1504    ----
   XDATA SIZE       =    224      90
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      1      23
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
